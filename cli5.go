package main

import (
	"fmt"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gdamore/tcell/v2"
)

const (
	// Dimensiones de la animación
	animWidth  = 32
	animHeight = 22

	// Velocidad mínima para caminar/correr
	minWalkSpeed = 10
	minRunSpeed  = 40

	// Duración de cada frame en ms
	frameDuration = 200
)

// Estados de la animación
var (
	currentWpm   = 0
	isSneaking   = false
	isJumping    = false
	showedJump   = true
	capsLock     = false
	currentFrame = 0
)

// Animaciones del perro - frames representados como matrices de bits
// Cada byte representa 8 píxeles, por lo que se necesitan (32*22)/8 = 88 bytes por frame
// Por simplicidad usamos estructuras reducidas aquí - datos de ejemplo

// Sit animation - 2 frames
var sit = [2][]byte{
	{
		// Frame 1 - Datos simplificados para ejemplo
		0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00,
		0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
		0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00,
		0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
		0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00,
		0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
		0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00,
		0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
		0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00,
		0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
		0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
	},
	{
		// Frame 2 - Datos simplificados para ejemplo
		0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00,
		0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
		0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00,
		0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
		0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00,
		0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
		0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00,
		0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
		0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00,
		0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
		0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
	},
}

// Walk animation - 2 frames
var walk = [2][]byte{
	{
		// Frame 1 - Datos simplificados para ejemplo
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x00, 0x00,
		0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x00, 0x00,
		0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x00, 0x00,
		0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x00, 0x00,
		0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x00, 0x00,
		0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	},
	{
		// Frame 2 - Datos simplificados para ejemplo
		0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
	},
}

// Run animation - 2 frames
var run = [2][]byte{
	{
		// Frame 1 - Datos simplificados para ejemplo
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00,
		0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00,
		0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00,
		0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00,
		0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00,
		0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	},
	{
		// Frame 2 - Datos simplificados para ejemplo
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x00, 0x00,
		0x00, 0x00, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x00, 0x00,
		0x00, 0x00, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x00, 0x00,
		0x00, 0x00, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x00, 0x00,
		0x00, 0x00, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x00, 0x00,
		0x00, 0x00, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
	},
}

// Sneak animation - 2 frames
var sneak = [2][]byte{
	{
		// Frame 1 - Datos simplificados para ejemplo
		0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
		0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
		0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
		0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
		0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
		0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	},
	{
		// Frame 2 - Datos simplificados para ejemplo
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
		0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
	},
}

// Bark animation - 2 frames
var bark = [2][]byte{
	{
		// Frame 1 - Datos simplificados para ejemplo
		0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0x00, 0x00,
		0x00, 0x00, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3,
		0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0x00, 0x00,
		0x00, 0x00, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3,
		0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0x00, 0x00,
		0x00, 0x00, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3,
		0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0x00, 0x00,
		0x00, 0x00, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3,
		0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0x00, 0x00,
		0x00, 0x00, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3,
		0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3,
	},
	{
		// Frame 2 - Datos simplificados para ejemplo
		0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,
		0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,
		0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,
		0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,
		0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,
		0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,
		0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,
		0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,
		0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,
		0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,
		0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,
	},
}

// Dibuja un pixel en la pantalla
func drawPixel(s tcell.Screen, x, y int, on bool) {
	if on {
		s.SetContent(x, y, '█', nil, tcell.StyleDefault.Foreground(tcell.ColorWhite))
	} else {
		s.SetContent(x, y, ' ', nil, tcell.StyleDefault)
	}
}

// Dibuja un frame de la animación
func drawFrame(s tcell.Screen, x, y int, frame []byte) {
	for j := 0; j < animHeight; j++ {
		for i := 0; i < animWidth; i++ {
			// Calcula qué byte y qué bit contiene este pixel
			byteIndex := (j*animWidth + i) / 8
			bitIndex := (j*animWidth + i) % 8

			// Evita acceso fuera de rango
			if byteIndex >= len(frame) {
				continue
			}

			// Obtiene el valor del bit
			on := (frame[byteIndex] & (1 << bitIndex)) != 0

			// Dibuja el pixel
			drawPixel(s, x+i, y+j, on)
		}
	}
}

// Actualiza la animación
func animateLuna(s tcell.Screen, x, y int) {
	// Limpia el área de la animación
	for j := 0; j < animHeight; j++ {
		for i := 0; i < animWidth; i++ {
			s.SetContent(x+i, y+j, ' ', nil, tcell.StyleDefault)
		}
	}

	// Maneja animación de salto
	if isJumping {
		if !showedJump {
			// Clear
			for i := 0; i < 5; i++ {
				s.SetContent(x+i, y-1, ' ', nil, tcell.StyleDefault)
			}
			showedJump = true
		}
	}

	// Cambia al siguiente frame
	currentFrame = (currentFrame + 1) % 2

	// Selecciona la animación según el estado actual
	if capsLock {
		drawFrame(s, x, y, bark[1-currentFrame])
	} else if isSneaking {
		drawFrame(s, x, y, sneak[1-currentFrame])
	} else if currentWpm <= minWalkSpeed {
		drawFrame(s, x, y, sit[1-currentFrame])
	} else if currentWpm <= minRunSpeed {
		drawFrame(s, x, y, walk[1-currentFrame])
	} else {
		drawFrame(s, x, y, run[1-currentFrame])
	}

	// Actualiza la pantalla
	s.Show()
}

// Maneja la entrada de teclado
func handleInput(s tcell.Screen, ev *tcell.EventKey) {
	switch ev.Key() {
	case tcell.KeyEscape, tcell.KeyCtrlC:
		s.Fini()
		os.Exit(0)
	case tcell.KeyUp:
		currentWpm += 10
		if currentWpm > 100 {
			currentWpm = 100
		}
	case tcell.KeyDown:
		currentWpm -= 10
		if currentWpm < 0 {
			currentWpm = 0
		}
	case tcell.KeyRune:
		switch ev.Rune() {
		case 'c':
			capsLock = !capsLock
		case 's':
			isSneaking = !isSneaking
		case ' ':
			isJumping = !isJumping
			showedJump = false
		case 'q':
			s.Fini()
			os.Exit(0)
		}
	}
}

// Muestra instrucciones en la pantalla
func showInstructions(s tcell.Screen) {
	instructions := []string{
		"Controles:",
		"  ↑/↓ - Aumentar/Disminuir velocidad",
		"  c   - Activar/Desactivar Caps Lock",
		"  s   - Activar/Desactivar sigilo",
		"  Espacio - Saltar",
		"  q/Esc/Ctrl+C - Salir",
		"",
		fmt.Sprintf("Velocidad actual: %d WPM", currentWpm),
		fmt.Sprintf("Estado: %s", getState()),
	}

	for i, line := range instructions {
		for j, r := range line {
			s.SetContent(1, 2+i, r, nil, tcell.StyleDefault)
			j++
		}
	}
}

// Obtiene el estado actual como texto
func getState() string {
	if capsLock {
		return "Ladrando"
	} else if isSneaking {
		return "Sigilo"
	} else if currentWpm <= minWalkSpeed {
		return "Sentado"
	} else if currentWpm <= minRunSpeed {
		return "Caminando"
	} else {
		return "Corriendo"
	}
}

func main() {
	// Inicializa la pantalla
	s, err := tcell.NewScreen()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error al crear la pantalla: %v\n", err)
		os.Exit(1)
	}

	if err := s.Init(); err != nil {
		fmt.Fprintf(os.Stderr, "Error al inicializar la pantalla: %v\n", err)
		os.Exit(1)
	}

	// Configura el estilo de pantalla
	s.SetStyle(tcell.StyleDefault.Background(tcell.ColorBlack).Foreground(tcell.ColorWhite))
	s.EnableMouse()
	s.Clear()

	// Canal para manejar señales de interrupción
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	// Canal para eventos
	quit := make(chan struct{})
	go func() {
		for {
			ev := s.PollEvent()
			switch ev := ev.(type) {
			case *tcell.EventKey:
				handleInput(s, ev)
			case *tcell.EventResize:
				s.Sync()
			case *tcell.EventMouse:
				// Opcional: manejar eventos del mouse
			}

			// Actualiza las instrucciones
			showInstructions(s)
			s.Show()
		}
	}()

	// Maneja señales de interrupción
	go func() {
		<-sigChan
		s.Fini()
		os.Exit(0)
	}()

	// Posición de la animación
	x, y := 40, 10

	// Bucle principal de animación
	for {
		select {
		case <-quit:
			return
		case <-time.After(time.Duration(frameDuration) * time.Millisecond):
			// Actualiza la animación
			animateLuna(s, x, y)
			showInstructions(s)
			s.Show()
		}
	}
}
